// ERN Language Code - Advanced Example
/*
 * This file demonstrates more complex features and nested structures
 * available within the ERN language grammar for rigorous testing.
 */

// Function to compute the Nth Fibonacci number using recursion.
// Demonstrates recursive calls and conditional logic.
function fibonacci(n) {
    if (n < 2) {
        return n;
    } else {
        // Recursive step: fib(n) = fib(n-1) + fib(n-2)
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

// Function to check if a number is prime.
// Demonstrates a while loop and basic arithmetic.
function is_prime(num) {
    i = 2;
    is_p = true;
    if (num < 2) {
        is_p = false;
    }

    while (i * i < num + 1) {
        // A simple modulo operator is not in the grammar, so we simulate it.
        // This is a placeholder for a more complex check.
        if (num > 3 and (num == i * (num / i))) {
            is_p = false;
        }
        i = i + 1;
    }
    return is_p;
}

// A function that uses another function and performs matrix operations.
function process_vectors(v1, v2) {
    // This function calculates a scaled dot product and uses it in a conditional.

    temp_result = 0;
    i = 0;
    while (i < 3) {
        temp_result = temp_result + v1[i] * v2[i];
        i = i + 1;
    }

    // Call another function and use its result.
    fib_val = fibonacci(5);

    scaled_result = temp_result * (fib_val - 2);

    return scaled_result;
}


// === MAIN PROGRAM LOGIC ===

// Variable declarations with various types.
vector_x = [100, 200, 300];
vector_y = [5, 4, 3];
is_processing = true;
threshold = 1500;
check_prime_num = 17;

// A complex matrix with nested vectors.
// Demonstrates nested literal structures.
data_matrix = [[1, 1, 2], [3, 5, 8], [13, 21, 34]];
another_matrix = [[1,0,0],[0,1,0],[0,0,1]];

// Perform an initial computation by calling a function.
initial_prod = process_vectors(vector_x, vector_y);

// Deeply nested conditional statement to test expression precedence and logic.
if ((initial_prod > threshold and is_processing) or (fibonacci(7) == 13)) {

    // Calculate a complex expression inside the if-block.
    // This demonstrates operator precedence, absolute value, and function calls.
    intermediate_value = |initial_prod - (threshold * 2)| + fibonacci(6);

    is_valid_prime = is_prime(check_prime_num);

    // Another level of nesting
    if (is_valid_prime and (intermediate_value > 100)) {

        // Accessing vector elements within an expression
        final_result = (data_matrix[0][1] + vector_x[2]) * 2;

    } else {
        // Type casting example
        final_result = (initial_prod * -1) as Int;
    }

} else {
    // Else block with a standalone function call and assignment.
    is_processing = false;
    final_result = -999;
    fibonacci(3); // Standalone call
}

// A simple while loop at the top level of the program.
i = 0;
while (i < 2) {
    // Function calls inside a loop.
    is_prime(i + 19);
    i = i + 1;
}
